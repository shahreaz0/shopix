"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenValidator = void 0;
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const jwks_rsa_1 = __importDefault(require("jwks-rsa"));
const TokenCacheWrapper_js_1 = require("./TokenCacheWrapper.js");
const claimsType = Object.freeze({
    scopes: 'scopes',
    roles: 'roles'
});
class TokenValidator {
    /**
     * Constructs a new instance of TokenValidator.
     * @param {Object} options Configuration options for the TokenValidator.
     * @param {boolean} [options.cache=true] Whether to cache the JWKS keys.
     * @param {number} [options.cacheMaxAge=86400000] The maximum age of the cache in milliseconds (default is 24 hours).
     * @param {string} options.jwksUri The URI to fetch the JWKS keys from.
     * @throws {Error} If the options parameter is not provided.
     */
    constructor(options) {
        var _a, _b;
        if (!options) {
            throw new Error('options is required');
        }
        const cache = (_a = options.cache) !== null && _a !== void 0 ? _a : true;
        this.client = (0, jwks_rsa_1.default)({
            cache,
            cacheMaxAge: (_b = options.cacheMaxAge) !== null && _b !== void 0 ? _b : 24 * 60 * 60 * 1000, // 24 hours in milliseconds
            jwksUri: options.jwksUri
        });
        if (cache) {
            this.cacheWrapper = new TokenCacheWrapper_js_1.TokenCacheWrapper(this.client, options);
            this.client.getSigningKey = this.cacheWrapper.getCacheWrapper();
        }
    }
    /**
     * Validates a JWT token.
     * @param {string} token The JWT token to validate.
     * @param {import('jsonwebtoken').VerifyOptions & { complete?: false } & { idtyp?: string, ver?: string, scp?: string[], roles?: string[] }} [options] Validation options.
     * @property {string[]} [options.allowedTenants] The allowed tenants for the JWT token. Compared against the 'tid' claim.
     * @property {string} [options.idtyp] The expected value of the 'idtyp' claim in the JWT token.
     * @property {string[]} [options.roles] Roles expected in the 'roles' claim in the JWT token.
     * @property {string[]} [options.scp] Scopes expected in the 'scp' claim in the JWT token.
     * @property {string} [options.ver] The expected value of the 'ver' claim in the JWT token.
     * @returns {Promise<import('jsonwebtoken').JwtPayload | string>} The decoded and verified JWT token.
     * @throws {Error} If the token is invalid or the validation fails.
     */
    validateToken(token, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const decoded = jsonwebtoken_1.default.decode(token, { complete: true });
            if (!decoded) {
                throw new Error('jwt malformed');
            }
            // necessary to support multitenant apps
            this.updateIssuer(decoded, options);
            const key = yield this.getSigningKey(decoded.header.kid);
            const verifiedToken = jsonwebtoken_1.default.verify(token, key, options);
            if (!options) {
                return verifiedToken;
            }
            const validators = [
                TokenValidator.validateIdtyp,
                TokenValidator.validateVer,
                TokenValidator.validateScopesAndRoles,
                TokenValidator.validateAllowedTenants
            ];
            validators.forEach(validator => validator(verifiedToken, options));
            return verifiedToken;
        });
    }
    static validateIdtyp(jwt, options) {
        if (options.idtyp &&
            options.idtyp !== jwt.idtyp) {
            throw new Error(`jwt idtyp is invalid. Expected: ${options.idtyp}`);
        }
    }
    static validateVer(jwt, options) {
        if (options.ver &&
            options.ver !== jwt.ver) {
            throw new Error(`jwt ver is invalid. Expected: ${options.ver}`);
        }
    }
    static validateScopesAndRoles(jwt, options) {
        var _a, _b;
        if (options.scp || options.roles) {
            const validateClaims = (claimsFromTheToken, requiredClaims, claimsType) => {
                const hasAnyRequiredClaim = requiredClaims.some(claim => claimsFromTheToken.includes(claim));
                if (!hasAnyRequiredClaim) {
                    throw new Error(`jwt does not contain any of the required ${claimsType}`);
                }
            };
            if (options.scp && options.roles) {
                if (jwt.scp) {
                    validateClaims(jwt.scp, options.scp, claimsType.scopes);
                }
                else if (jwt.roles) {
                    validateClaims(jwt.roles, options.roles, claimsType.roles);
                }
            }
            else if (options.scp) {
                validateClaims((_a = jwt.scp) !== null && _a !== void 0 ? _a : [], options.scp, claimsType.scopes);
            }
            else if (options.roles) {
                validateClaims((_b = jwt.roles) !== null && _b !== void 0 ? _b : [], options.roles, claimsType.roles);
            }
        }
    }
    static validateAllowedTenants(jwt, options) {
        if (options.allowedTenants && options.allowedTenants.length > 0) {
            if (!jwt.tid || !options.allowedTenants.includes(jwt.tid)) {
                throw new Error(`jwt tid is not allowed. Allowed tenants: ${options.allowedTenants.join(', ')}`);
            }
        }
    }
    /**
     * Clears the cache used by the TokenValidator.
     */
    clearCache() {
        var _a;
        (_a = this.cacheWrapper) === null || _a === void 0 ? void 0 : _a.cache.reset();
    }
    /**
     * Deletes a key from the cache.
     * @param {string} kid The key ID to delete from the cache.
     */
    deleteKey(kid) {
        var _a;
        (_a = this.cacheWrapper) === null || _a === void 0 ? void 0 : _a.cache.del(kid);
    }
    getSigningKey(kid) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = yield this.client.getSigningKey(kid);
            return key.getPublicKey();
        });
    }
    updateIssuer(jwt, options) {
        if (!(options === null || options === void 0 ? void 0 : options.issuer) || typeof jwt.payload !== 'object' || !jwt.payload.tid) {
            return;
        }
        if (typeof options.issuer === 'string') {
            if (options.issuer.toLowerCase().indexOf('{tenantid}') > -1) {
                options.issuer = options.issuer.replace(/{tenantid}/i, jwt.payload.tid);
            }
            return;
        }
        if (Array.isArray(options.issuer)) {
            options.issuer = options.issuer.map(issuer => {
                if (issuer.toLowerCase().indexOf('{tenantid}') > -1) {
                    return issuer.replace(/{tenantid}/i, jwt.payload.tid);
                }
                return issuer;
            });
            return;
        }
    }
}
exports.TokenValidator = TokenValidator;
